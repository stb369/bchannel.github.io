import { useEffect, useMemo, useState } from "react";
import { ethers } from "ethers";

// ==== è¨­å®š ====
const CONTRACT_ADDRESS = "0x..."; // ãƒ‡ãƒ—ãƒ­ã‚¤å…ˆ
const ABI = [
  "event MessagePosted(bytes32 indexed roomId, address indexed sender, string nickname, string content, uint256 timestamp)",
  "function postMessage(bytes32 roomId, string nickname, string content) payable",
  "function minFeeWei() view returns (uint256)"
];
const ROOM_NAME = "main";
const ROOM_ID = ethers.id(ROOM_NAME); // keccak256("main")

export default function App() {
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [contract, setContract] = useState(null);
  const [nickname, setNickname] = useState("åç„¡ã—");
  const [content, setContent] = useState("");
  const [messages, setMessages] = useState([]);
  const [minFee, setMinFee] = useState("0");

  // åˆæœŸåŒ–ï¼ˆMetaMaskï¼‰
  useEffect(() => {
    if (!window.ethereum) return;
    const p = new ethers.BrowserProvider(window.ethereum);
    setProvider(p);
    (async () => {
      const c = new ethers.Contract(CONTRACT_ADDRESS, ABI, await p.getSigner());
      setSigner(await p.getSigner());
      setContract(c);
      const min = await c.minFeeWei();
      setMinFee(min.toString());
    })();
  }, []);

  // å±¥æ­´èª­ã¿è¾¼ã¿ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆ from ãƒ–ãƒ­ãƒƒã‚¯ç¯„å›²ï¼‰
  const fetchLogs = async () => {
    if (!provider) return;
    const iface = new ethers.Interface(ABI);
    const filter = {
      address: CONTRACT_ADDRESS,
      topics: [
        iface.getEventTopic("MessagePosted"),
        ethers.zeroPadValue(ROOM_ID, 32), // indexed roomId
      ],
      fromBlock: 0, // æœ¬ç•ªã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥/ç¯„å›²çµã‚Šæ¨å¥¨
      toBlock: "latest"
    };
    const logs = await provider.getLogs(filter);
    const decoded = logs.map(l => {
      const parsed = iface.parseLog(l);
      return {
        sender: parsed.args.sender,
        nickname: parsed.args.nickname,
        content: parsed.args.content,
        timestamp: Number(parsed.args.timestamp)
      };
    });
    setMessages(decoded.sort((a,b)=>a.timestamp-b.timestamp));
  };

  useEffect(() => {
    fetchLogs();
    // ãƒ©ã‚¤ãƒ–è³¼èª­
    if (!provider) return;
    const ws = provider; // BrowserProviderã¯ãƒãƒ¼ãƒªãƒ³ã‚°ã€‚å¿…è¦ãªã‚‰WS RPCã‚’åˆ¥ã§ç”¨æ„
    // ã“ã“ã§ã¯ç°¡ç•¥ï¼šä¸€å®šé–“éš”ã§ãƒãƒ¼ãƒªãƒ³ã‚°
    const id = setInterval(fetchLogs, 5000);
    return () => clearInterval(id);
  }, [provider]);

  const post = async () => {
    if (!contract || !signer || !content.trim()) return;
    const fee = minFee === "0" ? 0n : BigInt(minFee);
    const tx = await contract.postMessage(ROOM_ID, nickname || "åç„¡ã—", content.trim(), { value: fee });
    await tx.wait();
    setContent("");
    fetchLogs();
  };

  const connect = async () => {
    if (!window.ethereum) { alert("MetaMaskã‚’å…¥ã‚Œã¦ãã ã•ã„"); return; }
    await window.ethereum.request({ method: "eth_requestAccounts" });
  };

  return (
    <div style={{ maxWidth: 720, margin: "2rem auto", fontFamily: "system-ui" }}>
      <h1>ğŸ—¨ï¸ Onchain Chat (Room: {ROOM_NAME})</h1>
      <button onClick={connect}>ã‚¦ã‚©ãƒ¬ãƒƒãƒˆæ¥ç¶š</button>
      <p>æœ€å°æ‰‹æ•°æ–™ï¼ˆweiï¼‰: {minFee}</p>

      <div style={{ border: "1px solid #ccc", padding: 12, height: 360, overflow: "auto", marginTop: 12 }}>
        {messages.map((m, i) => (
          <div key={i} style={{ marginBottom: 8 }}>
            <b>{m.nickname}</b> <small>({m.sender.slice(0,6)}â€¦{m.sender.slice(-4)})</small>
            <div>{m.content}</div>
            <small>{new Date(m.timestamp * 1000).toLocaleString()}</small>
            <hr/>
          </div>
        ))}
      </div>

      <div style={{ display: "flex", gap: 8, marginTop: 12 }}>
        <input value={nickname} onChange={e=>setNickname(e.target.value)} placeholder="åå‰" style={{ width: 120 }}/>
        <input value={content} onChange={e=>setContent(e.target.value)} placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸" style={{ flex: 1 }}/>
        <button onClick={post}>é€ä¿¡</button>
      </div>
    </div>
  );
}
