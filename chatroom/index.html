import { useEffect, useMemo, useState } from "react";
import { ethers } from "ethers";

// ==== 設定 ====
const CONTRACT_ADDRESS = "0x..."; // デプロイ先
const ABI = [
  "event MessagePosted(bytes32 indexed roomId, address indexed sender, string nickname, string content, uint256 timestamp)",
  "function postMessage(bytes32 roomId, string nickname, string content) payable",
  "function minFeeWei() view returns (uint256)"
];
const ROOM_NAME = "main";
const ROOM_ID = ethers.id(ROOM_NAME); // keccak256("main")

export default function App() {
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [contract, setContract] = useState(null);
  const [nickname, setNickname] = useState("名無し");
  const [content, setContent] = useState("");
  const [messages, setMessages] = useState([]);
  const [minFee, setMinFee] = useState("0");

  // 初期化（MetaMask）
  useEffect(() => {
    if (!window.ethereum) return;
    const p = new ethers.BrowserProvider(window.ethereum);
    setProvider(p);
    (async () => {
      const c = new ethers.Contract(CONTRACT_ADDRESS, ABI, await p.getSigner());
      setSigner(await p.getSigner());
      setContract(c);
      const min = await c.minFeeWei();
      setMinFee(min.toString());
    })();
  }, []);

  // 履歴読み込み（イベント from ブロック範囲）
  const fetchLogs = async () => {
    if (!provider) return;
    const iface = new ethers.Interface(ABI);
    const filter = {
      address: CONTRACT_ADDRESS,
      topics: [
        iface.getEventTopic("MessagePosted"),
        ethers.zeroPadValue(ROOM_ID, 32), // indexed roomId
      ],
      fromBlock: 0, // 本番はキャッシュ/範囲絞り推奨
      toBlock: "latest"
    };
    const logs = await provider.getLogs(filter);
    const decoded = logs.map(l => {
      const parsed = iface.parseLog(l);
      return {
        sender: parsed.args.sender,
        nickname: parsed.args.nickname,
        content: parsed.args.content,
        timestamp: Number(parsed.args.timestamp)
      };
    });
    setMessages(decoded.sort((a,b)=>a.timestamp-b.timestamp));
  };

  useEffect(() => {
    fetchLogs();
    // ライブ購読
    if (!provider) return;
    const ws = provider; // BrowserProviderはポーリング。必要ならWS RPCを別で用意
    // ここでは簡略：一定間隔でポーリング
    const id = setInterval(fetchLogs, 5000);
    return () => clearInterval(id);
  }, [provider]);

  const post = async () => {
    if (!contract || !signer || !content.trim()) return;
    const fee = minFee === "0" ? 0n : BigInt(minFee);
    const tx = await contract.postMessage(ROOM_ID, nickname || "名無し", content.trim(), { value: fee });
    await tx.wait();
    setContent("");
    fetchLogs();
  };

  const connect = async () => {
    if (!window.ethereum) { alert("MetaMaskを入れてください"); return; }
    await window.ethereum.request({ method: "eth_requestAccounts" });
  };

  return (
    <div style={{ maxWidth: 720, margin: "2rem auto", fontFamily: "system-ui" }}>
      <h1>🗨️ Onchain Chat (Room: {ROOM_NAME})</h1>
      <button onClick={connect}>ウォレット接続</button>
      <p>最小手数料（wei）: {minFee}</p>

      <div style={{ border: "1px solid #ccc", padding: 12, height: 360, overflow: "auto", marginTop: 12 }}>
        {messages.map((m, i) => (
          <div key={i} style={{ marginBottom: 8 }}>
            <b>{m.nickname}</b> <small>({m.sender.slice(0,6)}…{m.sender.slice(-4)})</small>
            <div>{m.content}</div>
            <small>{new Date(m.timestamp * 1000).toLocaleString()}</small>
            <hr/>
          </div>
        ))}
      </div>

      <div style={{ display: "flex", gap: 8, marginTop: 12 }}>
        <input value={nickname} onChange={e=>setNickname(e.target.value)} placeholder="名前" style={{ width: 120 }}/>
        <input value={content} onChange={e=>setContent(e.target.value)} placeholder="メッセージ" style={{ flex: 1 }}/>
        <button onClick={post}>送信</button>
      </div>
    </div>
  );
}
